{"version":3,"file":"static/js/271.408f8fab.chunk.js","mappings":"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","sources":["../node_modules/reselect/src/utils.ts","../node_modules/reselect/src/autotrackMemoize/proxy.ts","../node_modules/reselect/src/weakMapMemoize.ts","../node_modules/reselect/src/createSelectorCreator.ts","redux/selectors/users-selector.js","webpack://my-app/./src/components/Users/User/User.module.css?cfea","components/Users/User/User.jsx","webpack://my-app/./src/commonComponents/paginator/paginator.module.css?3777","commonComponents/paginator/paginator.js","components/Users/UsersFunc.jsx"],"sourcesContent":["import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = 'NOT_FOUND'\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    if (resultEqualityCheck) {\r\n      const lastResultValue = lastResult?.deref() ?? lastResult\r\n      if (\r\n        lastResultValue != null &&\r\n        resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n      ) {\r\n        result = lastResultValue\r\n        resultsCount !== 0 && resultsCount--\r\n      }\r\n\r\n      const needsWeakRef =\r\n        (typeof result === 'object' && result !== null) ||\r\n        typeof result === 'function'\r\n      lastResult = needsWeakRef ? new Ref(result) : result\r\n    }\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <InputSelectors extends SelectorArray, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from \"reselect\"\r\n\r\nconst usersSelectors = {\r\n    getUsers(state) {\r\n        return state.usersPage.users\r\n    },\r\n    getPageSize(state) {\r\n        return state.usersPage.pageSize\r\n    },\r\n    getCurrentPage(state) {\r\n        return state.usersPage.currentPage\r\n    },\r\n    getFetching(state) {\r\n        return state.usersPage.isFetching\r\n    },\r\n    getFollowIsFetching(state) {\r\n        return state.usersPage.followIsFetching\r\n    },\r\n    getTotalUsersCount(state) { \r\n        return state.usersPage.totalUsersCount\r\n    }\r\n}\r\n\r\nexport const getUsers = createSelector(usersSelectors.getUsers, (users) => {\r\n    return users\r\n})\r\n\r\nexport const getPageSize = createSelector(usersSelectors.getPageSize, (pageSize) => {\r\n    return pageSize\r\n})\r\n\r\nexport const getCurrentPage = createSelector(usersSelectors.getCurrentPage, (currentPage) => {\r\n    return currentPage\r\n})\r\n\r\nexport const getFetching = createSelector(usersSelectors.getFetching, (isFetching) => {\r\n    return isFetching\r\n})\r\n\r\nexport const getFollowIsFetching = createSelector(usersSelectors.getFollowIsFetching, (followIsFetching) => {\r\n    return followIsFetching\r\n})\r\n\r\nexport const getTotalUsersCount = createSelector(usersSelectors.getTotalUsersCount, (totalUsersCount) => {\r\n    return totalUsersCount\r\n})","// extracted by mini-css-extract-plugin\nexport default {\"profileInfo\":\"User_profileInfo__m7yO9\",\"img_block\":\"User_img_block__wmW+U\",\"img\":\"User_img__k-D9F\"};","import React from \"react\";\r\nimport c from './User.module.css';\r\nimport userPhoto from '../../../imgs/fixedUsersImg.jpg'\r\nimport { useDispatch } from \"react-redux\";\r\nimport { NavLink } from \"react-router-dom\";\r\nimport { followUserThunk, unfollow } from \"../../../redux/users-reducer\";\r\n\r\nconst User = ({id, photo, name, followIsFetching, followed}) => {\r\n    /*<img src={ props.photo != null ? \r\n        props.photo : \r\n        userPhoto}\r\n        className={c.img} />*/\r\n    \r\n    const dispatch = useDispatch()\r\n\r\n    return (\r\n        <div key={id}>\r\n                    <div className={c.profile}>\r\n                        <NavLink to={`/profile/${id}`} className={c.bl}>\r\n                            <div className={c.img_block}>\r\n                                <img src={!photo ? userPhoto : photo}\r\n                                    className={c.img} />\r\n                            </div>\r\n                        </NavLink>\r\n                        <div className={c.profileInfo}>\r\n                            <span>{name}</span>\r\n                            <span></span>\r\n                        </div>\r\n                    </div>\r\n                    <div>\r\n                        {followed ? <button onClick={() => \r\n                            dispatch(unfollow(id))\r\n                            }>Unfollow</button> : <button disabled={\r\n                                followIsFetching.some(itemId => itemId === id)\r\n                            } onClick={() => {\r\n                                    dispatch(followUserThunk(id))\r\n                            }\r\n                            }>Follow</button>}\r\n                    </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default User;","// extracted by mini-css-extract-plugin\nexport default {\"selectedPage\":\"paginator_selectedPage__eX1i6\",\"page\":\"paginator_page__gYxHe\",\"page_list\":\"paginator_page_list__eXPGY\",\"profile\":\"paginator_profile__vd0aM\",\"img_block\":\"paginator_img_block__VDRuW\",\"img\":\"paginator_img__yN7m6\"};","import React, { memo, useEffect } from \"react\";\r\nimport c from './paginator.module.css'\r\nimport { useDispatch } from \"react-redux\";\r\nimport { useState } from \"react\";\r\n\r\nconst Paginator = memo(({totalItemsCount, pageSize, onPageChange, currentPage, pageLimit = 20, pageNeighbours = 2}) => {\r\n\r\n    const totalPages = Math.ceil(totalItemsCount / pageSize);\r\n\r\n    const LEFT_PAGE = 1\r\n    const RIGHT_PAGE = totalPages;\r\n\r\n    const range = (from, to, step = 1) => {\r\n        let i = from;\r\n        const range = []\r\n\r\n        while (i <= to) {\r\n            range.push(i);\r\n            i += step\r\n        }\r\n\r\n        return range;\r\n    }\r\n\r\n    const totalNumbers = pageNeighbours * 2 + 3;\r\n    const totalPagesBlocks = totalNumbers + 2;\r\n\r\n    const fetchPages = () => {\r\n        if (totalPages > totalPagesBlocks) {\r\n            const startPage = Math.max(2, currentPage - pageNeighbours);\r\n            const endPage = Math.min(totalPages - 1, currentPage + pageNeighbours);\r\n            const pages = range(startPage, endPage);\r\n\r\n            const hasSwitchLeft = startPage > 1;\r\n            const hasSwitchRight = (totalPages - endPage) > 1;\r\n            const spillOffset = totalNumbers - (pages.length + 1);\r\n\r\n            if (hasSwitchLeft && !hasSwitchRight) {\r\n                \r\n                    const extraPages = range(startPage - spillOffset, startPage - 1);\r\n                    const finalPages = [LEFT_PAGE, ...extraPages, ...pages];\r\n                    return finalPages;\r\n            };\r\n            \r\n            if (!hasSwitchLeft && hasSwitchRight) {\r\n                    const extraPages = range(endPage + 1, endPage + spillOffset);\r\n                    const finalPages = [...pages, ...extraPages, RIGHT_PAGE];\r\n                    return finalPages;\r\n            }\r\n                \r\n            const newPages = [LEFT_PAGE, ...pages, RIGHT_PAGE];\r\n            return newPages;\r\n        }\r\n\r\n        return range(1, totalPages);\r\n    }\r\n\r\n    useEffect(() => {\r\n        fetchPages()\r\n    }, [currentPage])\r\n\r\n    const pages = fetchPages()\r\n    \r\n    return (\r\n        <>\r\n            <ul className={c.page_list}>\r\n                {pages.map( (page, id) => {\r\n                    if (page === LEFT_PAGE) return (\r\n                        <li key={id} className={c.page}>\r\n                            <a className={currentPage === page ? c.selectedPage : c.page} href=\"#\" onClick={() => onPageChange(page)}>\r\n                                <span>{LEFT_PAGE}</span>\r\n                            </a>\r\n                            <span>Previous</span>\r\n                        </li>\r\n                    )\r\n                    if (page === RIGHT_PAGE) return (\r\n                        <li key={id} className={c.page}>\r\n                            <a className={currentPage === page ? c.selectedPage : c.page} href=\"#\" onClick={() => onPageChange(page)}>\r\n                                <span>{RIGHT_PAGE}</span>\r\n                            </a>\r\n                            <span>Next</span>\r\n                        </li>\r\n                    );\r\n                    return (\r\n                        <li key={id} className={c.page}>\r\n                            <a className={currentPage === page ? c.selectedPage : c.page} href=\"#\" onClick={() => onPageChange(page)}>\r\n                                <span>{page}</span>\r\n                            </a>\r\n                        </li>\r\n                    )\r\n                })}\r\n            </ul>\r\n        </>\r\n    )\r\n})\r\n\r\nexport default Paginator;","import React, { useEffect, useMemo } from \"react\";\r\nimport c from './Users.module.css';\r\nimport { NavLink } from \"react-router-dom\";\r\nimport axios from \"axios\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport { followUserThunk, getUsersThunk, onPageChangeThunk, unfollow } from \"../../redux/users-reducer\";\r\nimport { getUsers, getCurrentPage, getPageSize, getFetching, getFollowIsFetching, getTotalUsersCount } from \"../../redux/selectors/users-selector\";\r\nimport User from \"./User/User\";\r\nimport Paginator from \"../../commonComponents/paginator/paginator\";\r\n\r\nconst Users = (props) => {\r\n\r\n    const currentPage = useSelector(state => getCurrentPage(state))\r\n    const pageSize = useSelector(state => getPageSize(state))\r\n    const users = useSelector(state => getUsers(state))\r\n    const isFetching = useSelector(state => getFetching(state))\r\n    const followIsFetching = useSelector(state => getFollowIsFetching(state))\r\n    const totalUsersCount = useSelector(state => getTotalUsersCount(state))\r\n\r\n    const dispatch = useDispatch()\r\n\r\n    useEffect( () => {\r\n        dispatch(getUsersThunk(currentPage, pageSize))\r\n    }, [])\r\n\r\n    const onPageChange = (pageNum) => {\r\n        dispatch(onPageChangeThunk(pageNum, pageSize))\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            {\r\n                /*pages.map(p => {\r\n                    return <span onClick={() => onPageChange(p)} className={currentPage === p ? c.selectedPage : c.page}>{p}</span>\r\n                })\r\n            */}\r\n            <Paginator totalItemsCount={totalUsersCount} pageSize={pageSize} onPageChange={onPageChange} currentPage={currentPage} />\r\n        <div>\r\n        </div>\r\n            {users.map((el) => \r\n                <User id={el.id} photo={el.photos.small} name={el.name} followed={el.followed} followIsFetching={followIsFetching}/>\r\n            )}\r\n        </div>\r\n\r\n    )\r\n}\r\n\r\nexport default Users;"],"names":["assertIsFunction","func","errorMessage","arguments","length","undefined","concat","TypeError","ensureIsArray","item","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","every","itemTypes","map","name","join","assertIsArrayOfFunctions","Symbol","Object","getPrototypeOf","Ref","WeakRef","StrongRef","value","_classCallCheck","_createClass","key","this","UNTERMINATED","TERMINATED","createCacheNode","s","v","o","p","weakMapMemoize","lastResult","options","fnNode","resultEqualityCheck","resultsCount","memoized","cacheNode","i","l","arg","objectCache","WeakMap","objectNode","get","set","primitiveCache","Map","primitiveNode","result","terminatedNode","apply","_lastResult$deref","_lastResult","lastResultValue","deref","clearCache","resetResultsCount","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key5","createSelectorCreatorOptions","memoize","memoizeOptions","_len2","_key6","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","pop","combinedOptions","_objectSpread","_combinedOptions$memo","_combinedOptions$args","argsMemoize","_combinedOptions$args2","argsMemoizeOptions","finalMemoizeOptions","devModeChecks","finalArgsMemoizeOptions","memoizedResultFunc","_toConsumableArray","selector","inputSelectorResults","inputSelectorArgs","push","collectInputSelectorResults","assign","resetDependencyRecomputations","resetRecomputations","createSelector","usersSelectors","state","usersPage","pageSize","currentPage","isFetching","followIsFetching","totalUsersCount","getUsers","users","getPageSize","getCurrentPage","getFetching","getFollowIsFetching","getTotalUsersCount","_ref","id","photo","followed","dispatch","useDispatch","_jsxs","children","className","c","profile","_jsx","NavLink","to","bl","img_block","src","userPhoto","img","profileInfo","onClick","unfollow","disabled","some","itemId","followUserThunk","Paginator","memo","totalItemsCount","onPageChange","_ref$pageNeighbours","pageLimit","pageNeighbours","totalPages","Math","ceil","LEFT_PAGE","RIGHT_PAGE","range","from","step","totalNumbers","totalPagesBlocks","fetchPages","startPage","max","endPage","min","pages","hasSwitchLeft","hasSwitchRight","spillOffset","extraPages","useEffect","_Fragment","page","href","props","useSelector","getUsersThunk","pageNum","onPageChangeThunk","el","User","photos","small"],"sourceRoot":""}